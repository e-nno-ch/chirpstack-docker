# Logging.
[logging]

# Log level.
#
# Options are: trace, debug, info, warn error.
level = "trace"


# PostgreSQL configuration.
[postgresql]

# PostgreSQL DSN.
#
# Format example: postgres://<USERNAME>:<PASSWORD>@<HOSTNAME>/<DATABASE>?sslmode=<SSLMODE>.
#
# SSL mode options:
#  * disable - no SSL
#  * require - Always SSL (skip verification)
#  * verify-ca - Always SSL (verify that the certificate presented by the server was signed by a trusted CA)
#  * verify-full - Always SSL (verify that the certification presented by the server was signed by a trusted CA and the server host name matches the one in the certificate)
dsn = "postgres://chirpstack:chirpstack@$POSTGRESQL_HOST/chirpstack?sslmode=disable"

# Max open connections.
#
# This sets the max. number of open connections that are allowed in the
# PostgreSQL connection pool.
max_open_connections = 10

# Min idle connections.
#
# This sets the min. number of idle connections in the PostgreSQL connection
# pool (0 = equal to max_open_connections).
min_idle_connections = 0


# Redis configuration.
[redis]

# Server address or addresses.
#
# Set multiple addresses when connecting to a cluster.
servers = ["redis://$REDIS_HOST/"]

# TLS enabled.
tls_enabled = false

# Redis Cluster.
#
# Set this to true when the provided URLs are pointing to a Redis Cluster
# instance.
cluster = false


# Network related configuration.
[network]

# Network identifier (NetID, 3 bytes) encoded as HEX (e.g. 010203).
net_id = "000000"

# Enabled regions.
#
# Multiple regions can be enabled simultaneously. Each region must match
# the 'name' parameter of the region configuration in '[[regions]]'.
enabled_regions = [
  "as923",
  "as923_2",
  "as923_3",
  "as923_4",
  "au915_0",
  "cn470_10",
  "cn779",
  "eu433",
  "eu868",
  "in865",
  "ism2400",
  "kr920",
  "ru864",
  "us915_0",
  "us915_1",
]


# API interface configuration.
[api]

# interface:port to bind the API interface to.
bind = "0.0.0.0:8080"

# Secret.
#
# This secret is used for generating login and API tokens, make sure this
# is never exposed. Changing this secret will invalidate all login and API
# tokens. The following command can be used to generate a random secret:
#   openssl rand -base64 32
secret = "you-must-replace-this"


[integration]
enabled = ["mqtt", "kafka"]

[integration.mqtt]
server = "tcp://$MQTT_BROKER_HOST:1883/"
json = true

# Kafka integration configuration.
[integration.kafka]

# Brokers.
brokers=[
  "$KAFKA_BROKER_HOST:$KAFKA_BROKER_PORT",
]

# TLS.
#
# Set this to true when the Kafka client must connect using TLS to the Broker.
tls=true

# Topic for events.
topic="prod.avro.chirpstack.measurements"

# Template for keys included in Kafka messages.
# Kafka uses the key for distributing messages over partitions. You can use
# this to ensure some subset of messages end up in the same partition, so
# they can be consumed in-order. And Kafka can use the key for data retention
# decisions.  A header "event" with the event type is included in each
# message. There is no need to parse it from the key.
event_key="application.{{application_id}}.device.{{dev_eui}}.event.{{event}}"

# Username (optional).
username="$KAFKA_BROKER_USERNAME"

# Password.
password="$KAFKA_BROKER_PASSWORD"

# Mechanism.
#
# Valid options are:
# * PLAIN
# * SCRAM-SHA-256
# * SCRAM-SHA-512
mechanism="SCRAM-SHA-512"

# Use JSON encoding instead of Protobuf (binary).
json=true
